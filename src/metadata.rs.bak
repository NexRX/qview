use derive_more::{Deref, DerefMut};
use moka::future::Cache;
use std::{sync::LazyLock, time::Duration};

macro_rules! cache {
    () => {
        Cache::builder()
            .max_capacity(10_000)
            .time_to_live(Duration::from_secs(60 * 30)) // 30 min TTL
            .build()
    };
}

macro_rules! new {
    ($struct:ident, $field:ident: $field_ty:ty) => {
        impl $struct {
            pub fn new(name: impl Into<String>, $field: $field_ty) -> Self {
                Self {
                    name: name.into(),
                    $field,
                }
            }
        }
    };
}

pub static METADATA: LazyLock<Cache<String, String>> = LazyLock::new(|| cache!());

#[derive(Clone, Debug)]
pub struct Column {
    pub name: String,
    pub data_type: String,
}

#[derive(Clone, Debug, Deref, DerefMut)]
pub struct Table {
    pub name: String,
    #[deref]
    #[deref_mut]
    pub columns: Cache<String, Column>,
}
new!(Table, columns: Cache<String, Column>);

#[derive(Clone, Debug, Deref, DerefMut)]
pub struct Schema {
    pub name: String,
    #[deref]
    #[deref_mut]
    pub tables: Cache<String, Table>,
}
new!(Schema, tables: Cache<String, Table>);

#[derive(Clone, Debug, Deref, DerefMut)]
pub struct Database {
    pub name: String,
    #[deref]
    #[deref_mut]
    pub schemas: Cache<String, Schema>,
}
new!(Database, schemas: Cache<String, Schema>);

#[derive(Clone, Debug, Deref, DerefMut)]
pub struct Metadata {
    #[deref]
    #[deref_mut]
    pub databases: Cache<String, Database>,
}

impl Metadata {
    pub async fn get_database(&self, name: &str) -> Option<Database> {
        self.databases.get(name).await
    }

    pub async fn get_schema(&self, database_name: &str, schema_name: &str) -> Option<Schema> {
        self.databases
            .get(database_name)
            .await?
            .schemas
            .get(schema_name)
            .await
    }

    pub async fn get_table(
        &self,
        database_name: &str,
        schema_name: &str,
        table_name: &str,
    ) -> Option<Table> {
        self.databases
            .get(database_name)
            .await?
            .schemas
            .get(schema_name)
            .await?
            .tables
            .get(table_name)
            .await
    }

    pub async fn get_column(
        &self,
        database_name: &str,
        schema_name: &str,
        table_name: &str,
        column_name: &str,
    ) -> Option<Column> {
        self.databases
            .get(database_name)
            .await?
            .schemas
            .get(schema_name)
            .await?
            .tables
            .get(table_name)
            .await?
            .columns
            .get(column_name)
            .await
    }

    pub async fn upsert_database(
        &self,
        database_name: impl Into<String>,
        schema: Option<Schema>,
    ) -> Database {
        let database_name = database_name.into();
        match self.databases.get(&database_name).await {
            Some(_) => (),
            None => {
                self.databases
                    .insert(
                        database_name.clone(),
                        Database::new(database_name.clone(), cache!()),
                    )
                    .await;
            }
        }
        self.databases
            .get(&database_name)
            .await
            .expect("Database should be found after insertion")
    }
}
